经验：
pool 生命周期，不需要让caller 显式调用destroy，而是在create的时候内部向pool注册一个cleanup handler，
这样就可以把pool内的对象生存周期和pool保持同步。 保证了生命周期的完整性，一个pool对应一个生命阶段。
固执是一件很低效的习惯，要学会审时度势，及时调整策略和目标，切实可行，不要死扛。
对性能有要求的地方，还是用str_t,因为不需要重复计算strlen

规模大一点，一口气写完会引入很多错误，改都改不完。 
每个模块做好自己的事，不要站在全局思考模块内部实现，这样可能让模块偷懒，就得让它实现得坐井观天。
返回值都用int 但每个模块有自己的宏定义返回，默认1成功，0失败。

[x]. str_t 要做成zero_terminated. 相应的，每个buf最后一个字节都要设置为\0, 不能用来读取实际数据。
[x]. conf中的一些运行配置： request_pool_size client_header_size
[x]. 处理好CRLF，LF
[x]. array elts 转换应该是(xxxx **) 二级指针，不是一级
[x]. array_init



. pool 生命周期管理
. default vhost, default location.
. str_t 要特别注意buf 要多分配一个字节， 边界判定条件也应该是end-1 > last, 最后一个字节用于存放\0
. 要特别注意buf 的边界情况。
. 系统整合， 头文件包含, typedef.h和utils.h/.c 太杂, conf.h 里有module_create_func.
. makefile
. module_default.
. str_t 和 char* conflicts a lot.  不如统一使用str_t好了。 str_t 太麻烦，但大部分场景下需要计算strlen
. 内存管理始终是个大问题啊, 尤其是生命周期的问题，老感觉容易出野指针。
. 把conf里的char* 全部变成str_t
一个人写代码真是寂寞，经常自己挖了个坑结果半天爬不出来。好怀念以前和别人商量商量着自己就爬出来/别人把我拉出坑的日子。

特别想搞清楚 nginx 的http_header 方法。






