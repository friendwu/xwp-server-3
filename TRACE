2013.4.2 下面的计划
A. static能用
功能完整，测试通过，学习各种gdb调试、测试工具。
通过基本性能测试（不要追求完美），学习各种性能测试工具。
完成基本部署，学习一些基本部署方法。

B. uwsgi 能用

C. 好用
专注吃透nginx/cherokee
把学到的好东西放到自己这里，慢慢优化自己的实现，总结经验。

加油！

一个人写代码真是寂寞，经常自己挖了个坑结果半天爬不出来。
好怀念以前和别人商量商量着自己就爬出来/别人把我拉出坑的日子。




经验：
pool 生命周期，不需要让caller 显式调用destroy，而是在create的时候内部向pool注册一个cleanup handler，
这样就可以把pool内的对象生存周期和pool保持同步。 保证了生命周期的完整性，一个pool对应一个生命阶段。
固执是一件很低效的习惯，要学会审时度势，及时调整策略和目标，切实可行，不要死扛。
对性能有要求的地方，还是用str_t,因为不需要重复计算strlen

规模大一点，一口气写完会引入很多错误，改都改不完。 
每个模块做好自己的事，不要站在全局思考模块内部实现，这样可能让模块偷懒，就得让它实现得坐井观天。
返回值都用int 但每个模块有自己的宏定义返回，默认1成功，0失败。

[x]. str_t 要做成zero_terminated. 相应的，每个buf最后一个字节都要设置为\0, 不能用来读取实际数据。
[x]. conf中的一些运行配置： request_pool_size client_header_size
[x]. 处理好CRLF，LF
[x]. array elts 转换应该是(xxxx **) 二级指针，不是一级
[x]. array_init



. pool 生命周期管理
. default vhost, default location.
. str_t 要特别注意buf 要多分配一个字节， 边界判定条件也应该是end-1 > last, 最后一个字节用于存放\0
. 要特别注意buf 的边界情况。
[x]. 系统整合， 头文件包含, typedef.h和utils.h/.c 太杂, conf.h 里有module_create_func.
. makefile
. module_default.
[x]. str_t 和 char* conflicts a lot.  不如统一使用str_t好了。 str_t 太麻烦，但大部分场景下需要计算strlen
. 内存管理始终是个大问题啊, 尤其是生命周期的问题，老感觉容易出野指针。
[x]. 把conf里的char* 全部变成str_t
. assert干扰了正常逻辑。
. 特别想搞清楚 nginx 的http_header 方法, 里面用了hash方法。
. strace gdb 多线程 gdb attach
. str_t 还是用得很纠结，尤其是在parse_url时，还要多用内存来strndup request_line
. 把一些独立的函数拆出来，方便单独测试。
. gdb 改代码同步测试。


. 看起来是正常了，实际正常吗？如何测试。


. set basic headers.
. default vhost.
. default location.
. guard timeout.
. special response.
. keep alive.
. parse_url 中减少内存分配,尤其注意path.
. http_status_line 是不是要返回一个空str_t 而不是null指针？
. HTTP_STATUS_OK 改为 <= HTTP_STATUS_FINE


不确定未来需求的情况下，先按目前最省事的方法来做，接口做好点就可以了。
